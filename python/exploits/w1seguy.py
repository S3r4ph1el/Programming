import string
import itertools

def hex_to_bytes(hex_str):
    return bytes.fromhex(hex_str)

def get_xor_char(byte_cifrado, char_plaintext):
    return chr(byte_cifrado ^ ord(char_plaintext))

if __name__ == "__main__":
    hex_encoded_ctf = "02003a363467291b23301330030c30227c1426271726057e253a040e2511243c0e7d312430383f39"
    ciphertext_bytes = hex_to_bytes(hex_encoded_ctf)
    
    expected_plaintext_start = "THM{"
    expected_plaintext_end = "}"
    key_length = 5
    
    deduced_key_chars = [None] * key_length

    print("Tentando deduzir partes da chave...")

    for i in range(len(expected_plaintext_start)):
        if i < key_length:
            char_cifrado = ciphertext_bytes[i]
            char_plaintext = expected_plaintext_start[i]
            deduced_char = get_xor_char(char_cifrado, char_plaintext)
            
            if deduced_key_chars[i] is not None and deduced_key_chars[i] != deduced_char:
                print(f"Conflito no key[{i}]: Já era '{deduced_key_chars[i]}', mas deduzimos '{deduced_char}'. Algo está errado ou a chave não é de 5 caracteres.")
                exit()
            
            deduced_key_chars[i] = deduced_char
            print(f"  key[{i}] = '{deduced_char}' (de '{chr(char_cifrado)}' ^ '{char_plaintext}')")

    last_ciphertext_index = len(ciphertext_bytes) - 1
    key_index_from_end = last_ciphertext_index % key_length

    print(f"\nDeducindo do final (}}):")
    char_cifrado_end = ciphertext_bytes[last_ciphertext_index]
    char_plaintext_end = expected_plaintext_end[-1]
    deduced_char_from_end = get_xor_char(char_cifrado_end, char_plaintext_end)

    if deduced_key_chars[key_index_from_end] is not None and \
       deduced_key_chars[key_index_from_end] != deduced_char_from_end:
        print(f"Conflito no key[{key_index_from_end}]: Já era '{deduced_key_chars[key_index_from_end]}', mas deduzimos '{deduced_char_from_end}' do final. Algo está errado ou a chave não é de 5 caracteres.")
        exit()
    
    deduced_key_chars[key_index_from_end] = deduced_char_from_end
    print(f"  key[{key_index_from_end}] = '{deduced_char_from_end}' (de '{chr(char_cifrado_end)}' ^ '{char_plaintext_end}')")


    print(f"\nPartes da chave deduzidas: {deduced_key_chars}")

    unknown_indices = [i for i, char in enumerate(deduced_key_chars) if char is None]
    
    if not unknown_indices:
        found_key = "".join(deduced_key_chars)
        print(f"\nCHAVE COMPLETA DEDUZIDA: {found_key}")

    print(f"\nIniciando brute-force para os índices desconhecidos: {unknown_indices}")
    
    key_chars_pool = string.ascii_letters + string.digits
    
    found_key = None
    found_plaintext = None

    for unknown_chars_tuple in itertools.product(key_chars_pool, repeat=len(unknown_indices)):
        current_key_candidate_list = list(deduced_key_chars)
        
        for i, unknown_idx in enumerate(unknown_indices):
            current_key_candidate_list[unknown_idx] = unknown_chars_tuple[i]
        
        key_candidate = "".join(current_key_candidate_list)
        
        decrypted_text = ""
        try:
            for i in range(len(ciphertext_bytes)):
                decrypted_char = chr(ciphertext_bytes[i] ^ ord(key_candidate[i % key_length]))
                decrypted_text += decrypted_char
        except Exception:
            continue

        if len(decrypted_text) >= len(expected_plaintext_start) + len(expected_plaintext_end) and \
           decrypted_text.startswith(expected_plaintext_start) and \
           decrypted_text.endswith(expected_plaintext_end) and \
           all(c in string.printable for c in decrypted_text):
            
            found_key = key_candidate
            found_plaintext = decrypted_text
            break

    if found_key:
        print(f"\nCHAVE ENCONTRADA: {found_key}")
        print(f"FLAG DESCRIPTOGRAFADA (provável): {found_plaintext}")
        print("Agora, conecte-se ao servidor e envie esta chave para obter a flag real!")
    else:
        print("\nChave não encontrada após dedução e brute-force dos caracteres restantes.")
