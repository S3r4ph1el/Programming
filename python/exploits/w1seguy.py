import string
import itertools

def hex_to_bytes(hex_str):
    # Converte uma string hexadecimal para uma lista de inteiros de bytes.
    return bytes.fromhex(hex_str)

def get_xor_char(byte_cifrado, char_plaintext):
    # Retorna o caractere XOR de um byte cifrado e um caractere plaintext.
    return chr(byte_cifrado ^ ord(char_plaintext))

if __name__ == "__main__":
    hex_encoded_ctf = "02003a363467291b23301330030c30227c1426271726057e253a040e2511243c0e7d312430383f39"
    ciphertext_bytes = hex_to_bytes(hex_encoded_ctf)
    
    expected_plaintext_start = "THM{"
    expected_plaintext_end = "}"
    key_length = 5
    
    # Lista para armazenar os caracteres deduzidos da chave
    # Usaremos None para caracteres desconhecidos
    deduced_key_chars = [None] * key_length

    print("Tentando deduzir partes da chave...")

    # --- Dedução do início da chave ---
    for i in range(len(expected_plaintext_start)):
        if i < key_length: # Garante que não excedemos o tamanho da chave
            char_cifrado = ciphertext_bytes[i]
            char_plaintext = expected_plaintext_start[i]
            deduced_char = get_xor_char(char_cifrado, char_plaintext)
            
            # Se já deduzimos este índice da chave, verificamos a consistência
            if deduced_key_chars[i] is not None and deduced_key_chars[i] != deduced_char:
                print(f"Conflito no key[{i}]: Já era '{deduced_key_chars[i]}', mas deduzimos '{deduced_char}'. Algo está errado ou a chave não é de 5 caracteres.")
                exit() # Sair se houver inconsistência
            
            deduced_key_chars[i] = deduced_char
            print(f"  key[{i}] = '{deduced_char}' (de '{chr(char_cifrado)}' ^ '{char_plaintext}')")

    # --- Dedução do final da chave ---
    # O índice do último caractere do texto cifrado
    last_ciphertext_index = len(ciphertext_bytes) - 1
    # O índice correspondente na chave (usando módulo key_length)
    key_index_from_end = last_ciphertext_index % key_length

    print(f"\nDeducindo do final (}}):")
    char_cifrado_end = ciphertext_bytes[last_ciphertext_index]
    char_plaintext_end = expected_plaintext_end[-1] # Pega o último caractere do 'expected_plaintext_end'
    deduced_char_from_end = get_xor_char(char_cifrado_end, char_plaintext_end)

    # Verifica a consistência com o que já foi deduzido para este índice da chave
    if deduced_key_chars[key_index_from_end] is not None and \
       deduced_key_chars[key_index_from_end] != deduced_char_from_end:
        print(f"Conflito no key[{key_index_from_end}]: Já era '{deduced_key_chars[key_index_from_end]}', mas deduzimos '{deduced_char_from_end}' do final. Algo está errado ou a chave não é de 5 caracteres.")
        exit()
    
    deduced_key_chars[key_index_from_end] = deduced_char_from_end
    print(f"  key[{key_index_from_end}] = '{deduced_char_from_end}' (de '{chr(char_cifrado_end)}' ^ '{char_plaintext_end}')")


    print(f"\nPartes da chave deduzidas: {deduced_key_chars}")

    # --- Brute-force no restante ---
    unknown_indices = [i for i, char in enumerate(deduced_key_chars) if char is None]
    
    if not unknown_indices:
        found_key = "".join(deduced_key_chars)
        print(f"\nCHAVE COMPLETA DEDUZIDA: {found_key}")

    print(f"\nIniciando brute-force para os índices desconhecidos: {unknown_indices}")
    
    # Caracteres válidos para a chave
    key_chars_pool = string.ascii_letters + string.digits
    
    found_key = None
    found_plaintext = None

    for unknown_chars_tuple in itertools.product(key_chars_pool, repeat=len(unknown_indices)):
        current_key_candidate_list = list(deduced_key_chars) # Copia a lista para modificar
        
        # Preenche os espaços desconhecidos com os caracteres da combinação atual
        for i, unknown_idx in enumerate(unknown_indices):
            current_key_candidate_list[unknown_idx] = unknown_chars_tuple[i]
        
        key_candidate = "".join(current_key_candidate_list)
        
        # Descriptografar e verificar o formato
        decrypted_text = ""
        try:
            for i in range(len(ciphertext_bytes)):
                decrypted_char = chr(ciphertext_bytes[i] ^ ord(key_candidate[i % key_length]))
                decrypted_text += decrypted_char
        except Exception: # Evitar erros de índice caso algo dê muito errado
            continue

        if len(decrypted_text) >= len(expected_plaintext_start) + len(expected_plaintext_end) and \
           decrypted_text.startswith(expected_plaintext_start) and \
           decrypted_text.endswith(expected_plaintext_end) and \
           all(c in string.printable for c in decrypted_text):
            
            found_key = key_candidate
            found_plaintext = decrypted_text
            break # Chave encontrada!

    if found_key:
        print(f"\nCHAVE ENCONTRADA: {found_key}")
        print(f"FLAG DESCRIPTOGRAFADA (provável): {found_plaintext}")
        print("Agora, conecte-se ao servidor e envie esta chave para obter a flag real!")
    else:
        print("\nChave não encontrada após dedução e brute-force dos caracteres restantes.")
